/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  v2412                                 |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       volVectorField;
    object      U;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

dimensions      [0 1 -1 0 0 0 0];

internalField   uniform (0 0 0);

boundaryField
{
    top
    {
        type            noSlip;
        // type            codedFixedValue;
        // value           uniform (0 0 0); // начальное значение (не важно, будет переопределено кодом)

        // // Name of generated boundary condition
        // name    rampedFixedValue;

        // code
        // #{
        //     // Параметры:
        //     const scalar a = 0.02;          // амплитуда a
        //     const scalar omega0 = 0.718;    // частота ω₀
        //     const scalar L = 0.6;          // длина L
        //     const scalar pi = 3.141595;          // длина L

        //     // Текущее время:
        //     const scalar t = this->db().time().value();

        //     // Координата x (предполагаем, что граница вдоль оси x)
        //     // Для каждой точки границы:
        //     const vectorField& faceCenters = patch().Cf();
        //     vectorField result(faceCenters.size(), vector::zero);

        //     forAll(faceCenters, faceI)
        //     {
        //         scalar x = faceCenters[faceI].x(); // координата x точки на границе
        //         result[faceI].y() = a * omega0 * cos(2 * pi * x / L) * sin(omega0 * t);
        //     }

        //     operator==(result);
        // #};

    }

    bottom
    {
        type            noSlip;
    }

        left
    {
        // type            fixedValue;
        // value           uniform (0 0 0);

	type  codedFixedValue;
	name  increaseToFixedValue;
	code
	   #{
               const vectorField& Cf = patch().Cf();
               vectorField& field    = *this;
               const scalar a0 = 0.11* 0.001;
               const scalar w0 = 0.628;
               const scalar H  = 0.4;
               const scalar pi = constant::mathematical::pi;
									             
               forAll(Cf, faceI)
               {
                   const scalar y = Cf[faceI][1];
                   const scalar t = this->db().time().value();
                   field[faceI]   = vector(a0*w0*sin(2*pi*y/H)*cos(w0*t),0,0);
               }
         #};//*/


    }

    right
    {
        type            noSlip;
    }

    frontAndBack
    {
        type            empty;
    }
}


// ************************************************************************* //
